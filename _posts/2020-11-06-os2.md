---
layout: post
title: 운영체제 기본-2
subtitle: 
gh-repo: 
gh-badge: [star, fork, follow]
tags: 운영체제
categories : OS
comments: true
---

운영체제 : 컴퓨터의 여러 응용 프로그램을 설치되게 해 주고, 여러 가지 장치를 효율적으로 작동하도록 하며, 사용자가 컴퓨터를 손쉽게 이용할 수 있도록 해 주는 프로그램의 집단

=> 사용자 인터페이스와 자원관리를 위한 프로그램의 집단



커널 : 운영체제의 각종 기능들 중 사용자와 실행 프로그램을 위해 매우 빈번하게 사용되는 부분을 말하고 컴퓨터가 처음 부팅될 때에 주기억 장치에 적재되어 시스템의 운영이 종료될 때까지 계속해서 주기억 장치에 남아 있게 되는 부분

=> 운영체제의 핵, 관리자, 메모리 상주 프로그램



운영체제 중에서 빈번히 그리고 빨리 실행돼야 할 프로그램을 디스크에 두었을 경우 이들이 실행될 때마다 주기억 장치로 불러들여야 할 텐데 이 일은 결국 디스크와 주기억 장치 사이의 입출력에 해당하는 일이며 많은 시간을 요구하게 되어 시스템의 성능이 매우 떨어지기 때문



유저 모드 실행 중 커널 모드에서 해야 할 일이 생기면 프로그램은 시스템 호출을 하게 되고 이후 그 일을 해 줄 운영체제 프로그램이 커널 모드에서 실행된 다음 다시 사용자 프로그램으로 복귀되도록 하는 것

시스템 콜은 이러한 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다. 



부팅 : 부트스트랩 로더가 커널을 찾아 메모리에 올리고 실행시켜주는 프로그램



레지스터 : 메모리에 있는 데이터 연산보다 레지스터에 있는 데이터 연산이 더 빠름



명령어 처리

fetch : 메모리에 있는 명령어를 읽어 cpu에 있는 레지스터로 갖고온다



인터럽트 : 각 자원들이 능동적으로 자신의 상태변화를 cpu에 알리는 방식

하드웨어 인터럽트/ 소프트웨어 인터럽트 로 나뉨

cpu 스스로 자신에게 인터럽트 해야하는 경우 => 트랩

운영체제가 프로그램을 죽임 시스템에 critical한 명령어 사용시, 커널모드 사용시에 시스템콜 발생하는 경우

즉, 트랩은 유저모드에서 발생하는 것임

ex) c언어 동적메모리 할당오류, 스택오버플로우, 0으로 나눌때 ...



**외부 인터럽트**

외부 인터럽트는 다음과 같이 입,출력장치, 타이밍 장치, 전원 등 외부적인 요인에 의해 발생합니다.

**전원 이상 인터럽트 :** 정전이되거나 전원 이상이 있는경우 발생합니다.

**기계 착오 인터럽트 :** CPU의 기능적인 오류 동작이 발생한 경우 발생합니다.

**외부 신호 인터럽트 :** 타이머에 의해 규정된 시간을 알리는경우, 키보드로 인터럽트 키를 누른 경우, 외부 장치로부터 인터럽트 요청이 있는경우 발생합니다.

**입출력 인터럽트 :** 입출력 Data의 오류나 이상 현상이 발생한 경우, 입출력장치가 데이터의 전송을 요구하거나 전송을 끝났음을 알릴경우 발생합니다.



**내부 인터럽트**

내부 인터럽트는 다음과 같이 잘못된 명령이나 데이터를 사용할 때 발생하며 트랩(Trap)이라고도 부릅니다.

**프로그램 검사 인터럽트 :** 0으로 나누기가 발생한 경우, OverFlow 또는 UnderFlow가 발생한경우, 프로그램에서 명령어를 잘못 사용한 경우, 부당한 기억장소의 참조와 같은 프로그램 상의 오류가 발생합니다.



**소프트웨어 인터럽트** 

소프트웨어 인터럽트는 프로그램 처리 중 명령의 요청에 의해 발생한 것으로, 가장 대표적인 형태는 감시 프로그램을 호출하는 SVC인터럽트가 있습니다.

**SVC인터럽트 :** 사용자가 SVC명령을 써서 의도적으로 호출한 경우, 복잡한 입출력 처리를 해야하는 경우, 기억장치 할당 및 오퍼레이터와 대화를 해야하는경우 발생합니다.

![image-20201113020318736](..\assets\post_img\os2_1.png)

![인터럽트 처리과정](..\assets\post_img\os2_2.png)

**1.** 프로그램 실행을 중단합니다.

**2.** 현재의 프로그램 상태를 보존합니다.

**3.** 인터럽트 처리 루틴을 실행합니다.

**4.** 인터럽트 서비스 루틴을 실행합니다.

**5,** 인터럽트 요청 신호가 발생했을 때 보관한 PC의 값을 다시 PC에 저장합니다.

**6.** PC의 값을 이용하여 인터럽트 발생 이전에 수행중이던 프로그램을 계속 실행합니다.



컨텍스트 스위칭?

멀티 프로세스 환경에서 cpu가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 cpu가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업을 말한다.

컨텍스트 : cpu가 프로세스를 실행하기 위한 해당 프로세의 정보들. pcb에 저장된다.

*컨텍스트 스위칭이 잦아지면 오버헤드가 발생하여 효율이 떨어진다.(스위칭때는 아무작업 못함)









시스템 콜 => 소프트웨어 인터럽트

폴링 : cpu가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인하는 방식, 폴링 간격을 적절히 정해야함. 폴링 이후 변화된 자신의 상태를 다음 번 폴링 때까지는 알릴 수 없다는 점이 문제



I/O 방식

프로그램 I/O : 시스템소프트웨어에 의한 입출력. 인터럽트 필요X, CPU가 지속적으로 완료여부 체크. CPU가 입출력 완료될때까지 다른 작업에 동원 못되므로 낭비가 심함



인터럽트 I/O : I/O시 CPU는 다른 작업에 활용. 입출력 완료시 인터럽트를 통해 CPU에 알려지는 방식.



DMA : 한번에 여러 정보를 CPU를 거치지 않고 메모리에 보내는 것.

CPU를 통하지 않고 주변기기의 인터페이스 장치에 제어권을 주어 직접 주기억장치와 데이터를 주고 받는 방식으로 액세스하여  데이터를 전송하는 방법.  입·출력 속도가 향상. 전송이 끝나면 DMA 제어기는 CPU를 인터럽트 한다.

DMA는 1개의 명령어에의해 1 개의 Block만을 입/출력한다.

Channel은 1개의 명령어에 의해 여러 개의 Block을 입/출력한다.



![img](..\assets\post_img\os2_3.png)

![img](..\assets\post_img\os2_4.png)



독립적인 입출력 : 입출력 장치들이 입출력 버스를 통해 CPU와 연결되어 있는 경우입니다. 메모리는 따로 메모리 버스를 통해 연결되어 있습니다. 입출력은 입출력을 담당하는 명령어를 통해 실행되는데, 입출력 버스를 통해 해당 장치의 지정, 데이터, 입출력을 구분해 주는 제어 값이 전달됩니다. 이 방식의 단점은 입출력 명령어가 명령어 집합에 추가되므로 제어 로직이 복잡해지고, 입출력 버스를 장착하는데 추가 비용이 소요됩니다.

메모리 주소 지정 입출력 : 입출력 장치들이 메모리와 함께 메모리 버스에 연결되어 있으며, 입출력을 위한 명령어를 따로 두어 사용하지 않고 메모리에 대한 명령어를 활용하여 실제 입출력하게 되는 방식입니다. 입출력 장치들은 각각 메모리의 한 번지를 할당받아 그 번지로의 Move, Load 작업은 곧 그 번지에 해당하는 장치로의 입출력이 되도록 하는 것입니다. 하지만 이처럼 번지를 할당하여 입출력을 처리하게 되면, 메모리를 동적으로 사용할 수 없게 됩니다.



프로그램 : 저장공간에 저장되어있는 명령어들?

프로세스 : OS가 관리하는 기본적인 단위. 실행중인 프로그램. CPU를 할당받는 단위



PCB: 프로세슷 제어 블록. 프로세스가 만들어져서 없어질 때까지 시스템 메모리에 저장되있다.

프로세스 번호, 프로세스 상태, 프로세스 우선순위, 프로그램 카운터 값, 메모리 포인터, 컨텍스트 데이터, 할당받은 자원들에 대한 목록,(List of open files), 계정 정보, 입출력 정보

![image-20201113023250367](..\assets\post_img\os2_5.png)

swapping?





스레드 : 스케줄링 단위.

멀티 쓰레드로 프로그램 만들시 자원 공유에 이점을 가진다. 쓰레드간 커뮤니케이션이 쉽다. 단일 쓰레드는 메모리 사용량이 높아질 수 있다. Sychronization문제를 안고있다.

