# 안드로이드 개념 정리

### 앱을 구성하는 항목 3가지

컴포넌트, 매니페스트 파일, 리소스



컴포넌트는 앱을 구성하는데 있어서 가장 핵심 요소 입니다.

**앱의 기능을 담당**하고 있고, 코드로 작성되어 있습니다.  



매니페스트 파일은 **시스템이 앱이 가지고 있는 모든 정보를 읽을 수 있는 명세서** 역할을 하는 파일입니다.

매니페스트 파일에 들어가야 하는 내용은 패키지명과 어떤 컴포넌트를 사용하는지에 관한 내용은 필수적으로 들어가야 합니다. 



리소스는 **앱이 사용하는 이미지, 동영상, 문자열과 같은 콘텐츠**를 말하고, 주로 컴포넌트의 시각적인 부분을 담당하고 있습니다.

![](C:\Users\ansdu\Downloads\android.png)

#### **" 가장 중요한 항목은 컴포넌트 "**

다시 정리하면 매니페스트 파일은 시스템이 컴포넌트를 실행시키기 위해 확인하는 항목이고, 리소스는 컴포넌트의 시각적인 요소를 담당하는 항목, 그리고 컴포넌트는 매니페스트파일과 리소스의 도움을 받아 앱을 실행시키는 항목이라고 보시면 됩니다. 

 

그럼 3개의 항목에 대해 좀 더 자세히 알아보도록 하겠습니다. 

먼저 알아 볼 항목은 가장 중요한 컴포넌트 입니다. 

 

컴포넌트는 앱이 시작되는 지점이면서 뚜렷한 기능을 가지고 있습니다.

이 기능에 따라 액티비티, 서비스, 브로드캐스트 리시버, 콘텐츠 프로바이더로 나누어집니다. 



### 안드로이드 4대 컴포넌트

액티비티 : 안드로이드에서 화면을 관리하고 사용자의 다양한 이벤트를 처리하는데 사용됩니다.(사용자와 상호작용을 할 수 있는 화면을 제공)

서비스 : 화면에서 보이지 않지만 특정한 기능을 백그라운드에서 처리하는데 사용됩니다.(앱이 종료되더라도 백그라운드에서 앱을 계속해서 실행 시켜주는 컴포넌트)

브로드캐스트 리시버 : 안드로이드에서 발생하는 특정 브로드캐스트 메시지(시스템이나 앱에서 발생한 메시지)를 처리하기 위한 컴포넌트입니다.

콘텐트 프로바이더 : 앱 사이의 데이터의 공유를 위한 인터페이스를 제공하는 컴포넌트입니다.



#### **" 액티비티는 가장 중요한 컴포넌트 "**

 

4개의 컴포넌트 중 사용자와 상호작용을 하고 사용자에게 화면을 제공하는건 유일하게 액티비티 밖에 없습니다. 

첫 앱 빌드에서도 봤듯이 액티비티만 존재해도 앱을 구성하는데 큰 무리가 없는 거 처럼 4개의 컴포넌트 중 가장 중요한 컴포넌트라고 할 수 있기 때문에 액티비티에 대해 좀 더 알아보도록 하겠습니다. 

액티비티는 사용자의 입력이나 터치 등 이벤트를 받을 수 있는 하나의 앱 화면입니다. 이 화면은 리소스의 레이아웃 폴더에 있는 XML 파일의 도움을 받아 사용자가 볼 수 있는 화면을 완성시킬 수 있습니다. 레이아웃의 도움을 받은 액티비티는 사용자와 상호작용을 할 수 있는 버튼과 같은 위젯( = 뷰 )와 이런 뷰의 위치를 정해주는 뷰 그룹으로 이루어집니다. 

![](C:\Users\ansdu\Downloads\android2.png)

이렇게 구성된 액티비티는 앱에 적어도 하나 이상은 존재합니다. 그리고 여러개의 액티비티는 사용자와의 상호작용으로 인해 현재 보고 있는 액티비티에서 다른 액티비티를 활성화 시킵니다. 

(여기서 활성화란 , 현재 보고 있는 액티비티가 아닌 다른 액티비티들은 보이지 않는 상태인데, 사용자에 의해서 보이지 않던 액티비티가 보이게 되는데 이런 현상을 표현 한것입니다.) 

활성화가 되는 액티비티는 2가지 종류가 있는데, 

현재 사용하고 있는 액티비티와 같은 앱에 속하는 액티비티 이거나 다른 앱에 속한 액티비티 입니다.

같은 앱에 속한 액티비티라는 말은 아래 이미지를 보시면 쉽게 이해 하실 수 있습니다.

![](C:\Users\ansdu\Downloads\android3.png)

카카오톡에는 여러 액티비티들이 존재하고 아래에 보이는 사람모양, 대화, #, 별표, ... 을 클릭하면 이런식으로 해당 액티비티가 보여지는 걸 볼 수 있습니다.

다른 앱에 속한 액티비티는 아래의 이미지를 보시면 됩니다.

![](C:\Users\ansdu\Downloads\android4.png)

카카오톡에서는 촬영이라는 기능이 있습니다. 촬영은 카카오톡 내부에 카메라 기능이 있는게 아니라, 안드로이드 기기에 있는 카메라 앱에 있는 촬영하는 액티비티를 활성화해서 사용하는 것 입니다. 



### 안드로이드 액티비티와 액티비티의 수명주기에 대해 설명해보세요

안드로이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다.

부모 액티비티에서 새로운 자식 액티비티를 실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가해 줘야합니다. 다음으로, 부모 액티비티에서 startActivity 메소드에 인텐트를 파라미터로 넘겨 실행하거나 startActivities 메소를 이용하여 여러 개의 액티비티를 실행할 수 있습니다.

액티비티의 실행과정은 첫 번째로, 부모 액티비티에서 자식 액티비티를 생성 및 호출합니다. 두 번째로, 액티비티 매니저 서비스가 해당 앱 프로세스에서 인텐트를 복사해온 후, 매니페스트 파일에서 해당 인텐트에 명시되어 있는 액티비티를 찾고 어떻게 실행시켜야할지 결정합니다. 세 번째로, 찾아낸 액티비티를 실행하고 다시 해당 앱 프로세스를 복사해서 넘겨줍니다. 그 외 자식 액티비티 내의 onCreat 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게 됩니다.

액티비티는 크게 3가지 상태가 존재합니다. 먼저, 실행(running)상태는 액티비티 스택의 최상위에 있으며 포커를 가지고 있어 사용자에게 보이는 상태입니다. 다음으로 일시 중지(paused)상태는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어서 포커스를 받지 못하는 상태를 말합니다. 예를 들어, 대화상자가 위에 있어 일부가 가려져 있는 경우를 말합니다. 마지막으로 중지 상태는 다른 액티비티에 의해 완전히 가려져서 보이지 않는 상태를 말합니다.

액티비티가 처음만들어지면 onCreate 메소드가 호출되서 레이아웃을 구섭합니다. 이후, onStart메소드가 화면에 보이기 직전에 호출됩니다. onResume 메소드가 사용자 상호작용(화면이 포커스를 얻었을 때)하기 바로 전에 호출됩니다. 이 3가지 메소드가 호출되면 액티비티는 실행 상태를 갖게됩니다. 이후 포커스를 잃었을 때, onPause 메소드가 호출되고 일시중지 상태가 됩니다. 일시중지 상태에서 다시 포커스를 획득하면 onResume 메소드가 호출되거나 다른 액티비티에 의해서 완전히 화면이 가려졌는지 여부를 확인하여 가려져 보이지 않은 경우, onStop메소드가 호출되어 중지 상태가 됩니다. 정지 상태에서 다시 화면이 보이기 직전에 onRestart메소드가 호출되고 onStart메소드가 차례로 호출됩니다. 그 외 finish 메소드가 실행되어 해당 액티비티가 종료되기 직전에 onDestroy메소드가 실행됩니다.

가끔은 일시중지나 중지상태에서 시스템이 메모리가 부족하다고 판단될 경우, onCreate 메소드부터 다시 해당 액티비티를 구동합니다. onStop, onResume메소드 호출이 생략됩니다. 따라서 onSaveInstanceState, onRestoreInstanceState 메소드를 이용해 액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의해 줄 수 있습니다.**" 액티비티를 활성화시키는 방법은 인텐트"**

 

현재 사용하고 있는 액티비티에서 다른 액티비티를 활성화할 때, 액티비티가 직접 다른 액티비티를 활성화 시키는 것은 아닙니다. 안드로이드 앱은 인텐트(Intent)를 사용해서 시스템에게 액티비티의 실행을 요청하는 정보를 담은 메세지입니다.

( **액티비티를 중심이기 때문에 액티비티의 실행을 요청한다고 썻지만 실제로는 컴포넌트( 액티비티, 서비스, 브로드캐스트리시버) 를 활성화 시키는 것입니다.** )



![](C:\Users\ansdu\Downloads\android5.png)

액티비티를 실행하는 방식은 위에서 말했던 거처럼 앱 내부의 액티비티를 활성화하는 방법과 앱 외부에 있는 액티비티를 활성화하는 방법이 있습니다. 

전자의 방식을 명시적 인텐트라고 말하고, 후자의 방식을 암시적 인텐트라고 말합니다.

그럼 명시적 인텐트부터 알아보도록 하겠습니다. 

명시적 인텐트는 주로 같은 앱 안에서 액티비티를 활성화 시킬 때 사용합니다. 

사용 법은 내부 액티비티의 위치를 정확하게 기입하는 것입니다.

![android6](C:\Users\ansdu\Downloads\android6.png)

그림 6 명시적 인텐트

암시적 인텐트는 다른 앱의 액티비티를 활성화 시킬 때 사용합니다. 

현재 실행되고 있는 액티비티에서는 다른 앱의 액티비티의 이름을 알 수 없습니다. 

그렇기 때문에 암시적 인텐트로 처리할 작업을 담아 시스템에게 알려주면,

시스템에서는 활성화 될 수 있는 액티비티를 가진 앱들을 사용자에게 제공해 줍니다. 

#### ![android7](C:\Users\ansdu\Downloads\android7.png)

#### **"암시적 인텐트는 인텐트 필터가 처리"**

여기서 궁금한 점이 생길 것입니다. 어떻게 시스템은 암시적인텐트를 처리해서 가장 적합한 앱들을 제공해 주는가?

이러한 방법이 가능한 이유는 인텐트 필터의 도움 때문입니다. 

인텐트 필터에 대해서 좀 더 이해하기 쉬울려면 관점을 바꿔야 합니다. 

그 동안의 관점은 사용 중인 액티비티를 중심으로 다른 액티비티(= 활성화 될) 를 바라 보고 있었다면,

잠깐 다른 액티비티(= 활성화 될)가 중심인 관점으로 변해야 합니다.

인텐트 필터는 다른 앱(= 사용 중인 액티비티)에서 전달 된 암시적 인텐트가 액티비티를 활성화 시킬 수 있는지

판별 하고, 활성화 시킬 액티비티가 존재한다면 그 앱을 사용자에게 제공해주는 

![android8](C:\Users\ansdu\Downloads\android8.png)

그림 8 검은색 - 인텐트 필터



#### **"리소스의 가장 큰 특징은 코드와 분리되어서 관리"**

안드로이드 앱은 코드 + 리소스로 이루어져있습니다.

리소스가 가진 가장 큰 특징은 앱에서 코드는 리소스와 분리되어서 관리된다는 점입니다.

이렇게 관리하게 되면 코드를 바꾸지 않아도 리소스의 변경만으로 앱을 관리 할 수 있고, 그뿐만 아니라 다양한 기기나 현지 언어에 맞춰 앱을 유연하게 관리 할 수 있습니다.

![android9](C:\Users\ansdu\Downloads\android9.png)

그림 9는 리소스의 구성을 보여 줍니다. 

리소스는 주로 컴포넌트의 시각적인 부분을 담당하고 그 중에서도 액티비티에 많은 연관을 가지고 있습니다. 

액티비티의 이미지를 담당하는 drawable, 액티비티의 레이아웃을 담당하는 layout, 컴포넌트의 속성인 values, 아이콘 해상도를 담당하는 mimap으로 이루어져 있습니다. 그 이외에 애니메이션, 메뉴와 같은 디렉토리도 있습니다.

 

이렇게 구성되어있는 리소스를 가지고 다양한 기기나 현지 언어 맞춰 앱을 관리하는데 무리가 있습니다. 

이런 상황을 대처하기 위해서 대체 리소스를 제공해 앱을 유연하게 관리 할 수 있습니다. 







### 프래그먼트의 생명주기에 대해서 설명하세요.

onAttach함수가 onCreat이전에 호출됩니다. 그 이후 onCreate 함수가 호출되고, onCreateView에서 LayouyInflater로 UI관련 작업을 할 수 있습니다. 그리고 화면이 포커스를 잃었을 때는 onPause onStop onDestoryView가 호출되고 종료시에 onDestroy onDetach()가 호출됩니다.



### 안드로이드의 매니페스트 파일에 대해서 설명해보세요.

 매니페스트 파일은 앱의 이름, 버전, 구성요소, 권한, 액티비티와 같은 컴포넌트에 대한 정보 등 앱의 실행에서 꼭 필요한 정보가 저장되어 있는 파일입니다. xml파일로 프로젝트 최상위에 존재합니다. 컴포넌트를 실행시킬 때 항상 매니페스트 파일에서 실행할 컴포넌트를 확인하는 역할.

태그 구성으로 가장 위는 manifest태그가 존재하고 패키지명, 버전 등이 기재됩니다.

application태그에는 앱 아이콘, 앱 이름 등의 앱의 세부 정보가 저장됩니다.

activity태그에는 액티비티 클래스명과 액티비티 이름을 정의합니다.

activity하위에는 intent-filter태그를 이용해서 액티비티에 대한 인텐트 작업시 필요한 action과 category를 정의합니다.

앱에서 사용할 컴포넌트를 선언하는 <component> 태그 입니다

(여기서는 액티비티를 선언했습니다)

service, reciver,provider태그에는 서비스, 리시버, 프로바이더에 대한 내용이 정의되어 있습니다.

permission 태그에는 앱에서 필요한 권한을 정의합니다.

그밖에 sdk버전을 지칭하는 uses-sdk와 다른 패키지를 등록할 수 있는 uses-library등이 존재합니다.

위에서 설명했던 인텐트 필터를 선언할 수 있습니다. 

​    ![android10](C:\Users\ansdu\Downloads\android10.png)







### 안드로이드 인플레이션에 대해 설명해보세요

### webview란

안드로이드 프레임워크에 내장된 컴포넌트로 view형태로 임베딩할 수 있는 형태이다.

웹페이지를 보거나 안드로이드 앱 안에서 html을 호출하여 앱을 구현하는 하이브리드 앱을 개발하는데에도 많이 사용된다.



### rxjava란?

Reactive programming을 기반으로한 언어입니다.

즉 Reactive Extension의 JVM버전입니다.

비동기 데이터처리를 효율적으로 할 수 있는 장점이 있습니다,



### Reactive Programming은?

컴퓨팅으로써 반응형 프로그래밍은 데이터의 흐름과 변화에 대한 전달을 기반을 h하는 프로그래밍 패러다임이다. 끊임없이 요청/변경되는 데이터에 반응하기 위해 나온 Reactive Programming은 데이터를 처리함에 있어서 비동기적으로 데이터를 처리할 때 효율적으로 할 수 있도록 하기 위한 방법입니다.

반응형 프로그래밍의 특징

for if while 같은 것이 아니라 sql쿼리 같은 선언형으로 구성됩니다.

또 함수를 단지 호출하는 대상이 아니라 변수로도 혹은 인자로도 넘길 수 있습니다.

이러한 함수형언어의 도구들을 자유롭게 활용해양 합니다.(자바의 람다표현식)



### 코틀린의 장점

기존의 자바 코드의 보일러 플레이트 구문을 최소화 시킬 수 있습니다.

기존의 자바에서도 람다표현식을 이용하여 코드의 간소화를 위해 노력했습니다.

java8에서는 라이브러리를 사용하지 않고 람다표현식이 가능합니다.

하지만 안드로이드 스튜디오 2.4 이상부터 jdk 1.8로 빌드가 가능하고 minsdk도 24이기 때문에 실질적으로 사용하지 못하는 것으로 알고있습니다. 즉 j아1.6기반의 api와 문법적으로 조금 추가된 형태로 빌드 할수 있다고 봅니다.

안드로이드의 대표적인 보일러 플레이트 구문은 레이아웃에 정의한 뷰 레퍼런스를 가지고 오는 부분이나 sqlite트랜잭션을 처리하는 부분이 있습니다.

또 자바8의 스트림 api를 사용할 수도 없습니다.

스트림에 대한 대비로는 streamsupport, Lightweight-Stream-Api가 있습니다.

RxJava또한 자바8 스트림의 훌륭한 대안이고 안드로이드 커뮤니티에서 많이 쓰이고 있습니다.

하지만 위의 라이브러리들의 의존성문제와 기존 라이브러리에 대한 학습 등이 부담으로 다가온다는 사실이 있습니다.

코틀린의 좋은점으로는 NullPointException 다루기, 보일러 플레이트 개선하기, Collection에 filter, map, foreach 같은 고차 함수를 적용할 수 있고, 변경학능한 컬렉션과 불가능한 컬렉션을 엄격히 구분합니다, 서버에서 수신받은 데이터를 컬렉션으로 다룰 일이 많기 때문에 코드를 보다 간결하고 안전하게 만드는 데 도움이 됩니다. 또, 확장함수라는 강력한 기능도 있습니다.

자바와 호완성이 좋고 기존라이브러리를 제약없이 사용할 수 있습니다.

새로운 언어를 배워야한다는 부담감과 기술적이슈가 발생했을 때 대응기간이 상대적으로 길어질 수 있다는 단점도 있습니다.



### 안드로이드의 테스크란?

task는 어플에서 실행되는 액티비티를 관리하는 스택입니다. 후입선출 형태로 나중에 적재된 액티비가 가장 먼저 사용됩니다. 최초로 적재된 액티비티는 root 액티비티라고 하면 마지막에 적재된 액티비티는 탑 액티비티라고 합니다.

flag를 이용하여 액티비티의 흐름을 제어 할 수 있습니다.

 

### Realm이란?

sqlite,realm은 안드로이드 단말에서 사용하는 관계형 데이터베이스입니다.

sqlite는 오픈소스 데이터베이스로 os와 상호작용하기 위해 sqliteOpenHelper인터페이스를 이용합니다. sqlite는 c언어로 되어있고 경량데이터베이스이며 하나의 디스크 파일에 모든 데이터를 저장할 수 있습니다.

Realm은 크로스 플랫폼 기반의 모바일 데이터베이스입니다. ios와 android 모두 사용이 가능하며 성능 및 효율성이 우수합니다. 설치도 간편하며 쿼리 응답속도도 기타 ORMLite나 SQLite보다 더 좋습니다. 크로스 플랫폼이기 때문에 협업에서 유용합니다.

특징으로는 zero-copy모델을 사용하기 때문에 데이터 객체 자체에서 그대로 작업이 가능합니다. 크로스 플랫폼이기 때문에 특정 os를 가리지 않고 동기화 될수 있습니다.

ACID를 준수합니다.

Realm은 데이터베이스 컨테이너의 인스턴스입니다.

Sqlite 기반의 ORM 프레임워크입니다.



###   RestAPI란? (Representation State Transfer)

웹상에 존재하는 모든 자원에 URI를 부여하여 사용하는 방법입니다. (비연결성, URI로 자원에 접근) HTTP웹표준을 이용하여 HTTP의 캐싱을 활용할 수 있다는 장점이있스빈다. 그리고 구조가 명확하여 클라이언트와 서버에서 개발해야할 부분이 명확해지고 URI만 봐도 어떤 요청인지 파악될 수 있게 직관적이다 라는 특징이 있습니다.



### 하이브리드 앱이란?

네이티브 앱처럼 하드웨어 기능들을 사용할 수 있으며 마켓에 등록이 가능하며 배포후에도 웹만 연결되어 있다면 수정/보완을 할수 잇스빈다. 또한, 하나의 소스로 아이폰과 안드로이드에 맞게 포장이 가능하며 핵심 부분은 웹 앱 기술로 빠르게 제작이 가능하여 개발 비용이 적어질수 있습니다.

실제 핵심기능은 코드로 구현하고 지속적으로 업데이트 할 부분은 웹에서 관리하는 기능입니다.



### FCM의 구동 원리? (Firebase Cloud Messaging의 약자)

본연의 서버의 기능을 수행하면서 또 하나의 복잡한 알림 기능까지 포함한다면 서버의 속도는 처리량이 많아 느려질 것이다. 따라서 이러한 해결책으로 알림의 기능은 다른 서버가 제공을 해주고 본 서버는 알림기능을 제공하는 서버에 알림이 있는지 요청을 해서 정보를 가져오는 구조이다.

FCM의 동작을 위해서 HTTP나 XMPP로 FCM과 통신하는 서버와 클라이언트 앱이 필요합니다.

동작 순서

디바이스에 앱이 설치된후 최초 실행되면서 고유 식별자인 디바이스 토큰이 발급된다. 이 토큰을 앱 서버에 등록한다.

앱 서버에서 FCM 연결 서버로 푸시 알림을 요청한다. 이때 준비물은 디바이스 토큰과 API 서버 키이다.

FCM 연결 서버는 토큰을 대상으로 알림 메시지를 푸시한다.

​    